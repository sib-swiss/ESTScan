#!/usr/local/bin/perl

################################################################################
#
# build_model
# -----------
# 
# Claudio Lottaz, SIB-ISREC, Claudio.Lottaz@isb-sib.ch
# Christian Iseli, LICR ITO, Christian.Iseli@licr.org
#
# Copyright (c) 1999 Swiss Institute of Bioinformatics. All rights reserved.
#
################################################################################

use strict;
use EMBLFile;
use FASTAFile;
use CONFile;
use Symbol;
use POSIX;

use vars qw($VERSION);
$VERSION = 0.01;

# global variables
my $verbose = 1;
my $dosplit = 0;
my $forcedtuplesize = undef;
my $forcedminmask = undef;
my $forcedpseudocounts = undef;
my $forcedminscore = undef;
my $forcedstartlength = undef;
my $forcedstartpreroll = undef;
my $forcedstoplength = undef;
my $forcedstoppreroll = undef;

my $datadir = '.';
my $filestem = '';

require "build_model_utils.pl";

################################################################################
#
#   Check command-line for switches
#

my $usage = "Usage: build_tables [options] <conf-files>\n" .
    "       where options are:\n" .
    "        -q       don't log on terminal\n" .
    "        -e       split extracted data into training and test sets\n" .
    "        -t <int> force tuple size, overwrites entry in config-files\n" .
    "        -m <int> force minimal mask, overwrites entry in config-files\n" .
    "        -p <int> force pseudocounts, overwrites entry in config-files\n" .
    "        -s <int> force minimal score, overwrites entry in config-files\n" .
    "        -l <int> force length of start profile (in codons/triplets)\n" .
    "        -r <int> force start profile's preroll in 5'UTR (in codons/triplets)\n" .
    "        -L <int> force length of stop profile (in codons/triplets)\n" .
    "        -R <int> force sop profile's preroll in 5'UTR (in codons/triplets)\n" .
    "More information is obtained using 'perldoc build_tables'\n";

while ($ARGV[0] =~ m/^-/) {
    if ($ARGV[0] eq '-q') { shift; $verbose = 0; next; }
    if ($ARGV[0] eq '-e') { shift; $dosplit = 1; next; }
    if ($ARGV[0] eq '-t') { shift; $forcedtuplesize    = shift; next; }
    if ($ARGV[0] eq '-m') { shift; $forcedminmask      = shift; next; }
    if ($ARGV[0] eq '-p') { shift; $forcedpseudocounts = shift; next; }
    if ($ARGV[0] eq '-s') { shift; $forcedminscore     = shift; next; }
    if ($ARGV[0] eq '-l') { shift; $forcedstartlength  = shift; next; }
    if ($ARGV[0] eq '-r') { shift; $forcedstartpreroll = shift; next; }
    if ($ARGV[0] eq '-L') { shift; $forcedstoplength   = shift; next; }
    if ($ARGV[0] eq '-R') { shift; $forcedstoppreroll  = shift; next; }
    die "Unrecognized switch: $ARGV[0]\n$usage";
}
if ($#ARGV < 0) { die "No configuration file specified\n$usage"; }

################################################################################
#
#   Main-loop through all specified config-files
#

my $parFile;
while($parFile = shift) { 
    my($organism, $dbfiles, $ugdata, $estdata, $datadir2, $filestem2, 
       $rnafile, $estfile, $estcdsfile, $estutrfile, $trainingfile, $testfile, 
       $utrfile, $cdsfile, $tuplesize, $minmask, $pseudocounts, $minscore, 
       $startlength, $startpreroll, $stoplength, $stoppreroll, $smatfile,
       $estscanparams, $nb_isochores, $isochore_borders) =
	   readConfig($parFile, $forcedtuplesize, $forcedminmask, $forcedpseudocounts, 
		      $forcedminscore, $forcedstartlength, $forcedstartpreroll,
		      $forcedstoplength, $forcedstoppreroll, $verbose);
    log_open("readconfig.log");
    $datadir = $datadir2; $filestem = $filestem2;
    showConfig($parFile, $organism, $dbfiles, $ugdata, $estdata, $datadir, 
	       $rnafile, $estfile, $estcdsfile, $estutrfile, $trainingfile, $testfile, 
	       $utrfile, $cdsfile, $tuplesize, $minmask, $pseudocounts, $minscore, 
	       $startlength, $startpreroll, $stoplength, $stoppreroll, $smatfile, 
	       $estscanparams, $nb_isochores, $isochore_borders);
    log_close();

    # extract and analyse data
    log_open("extract_data.log");
    extract_mRNAs($dbfiles, $organism, $rnafile);
    my $gc_histogram = analyzeGC($rnafile);
    my $isochores = computeIsochores($nb_isochores, $isochore_borders, $gc_histogram);
    log_close();

    log_open("process_data.log");
    if ($dosplit) { splitTraining($rnafile, $trainingfile, $testfile, $isochores); }
    else { 
	symlink($rnafile, $trainingfile); 
	symlink($rnafile, $testfile); 
	splitIsochores($rnafile, $isochores);
    }
    maskRedundancy($minmask, $isochores);
    log_close();

    # generate codon usage and transition probability tables
    log_open("generate_tables.log");
    if (-s "$smatfile") { log_print(" - $smatfile already exists, skipped"); }
    else {
	generateEmissionTables($tuplesize, $pseudocounts, $minscore, 
			       $startlength, $startpreroll, $stoplength, $stoppreroll,
			       $isochores, $smatfile, $minmask, $parFile);
    }
    log_close();
    print "$parFile done.\n";
}

exit(0);

################################################################################
#
#   Extract mRNA entries
#

sub extract_mRNAs {
    # Find all full-length messenger RNA entries of the given species
    # ($organism) in the given databse ($dbfiles) and writes them in
    # FASTA format with CDS annotation in the header ($rnafile). Tries
    # to guess whether RefSeq or EMBL data is provided.

    my($dbfiles, $organism, $rnafile) = @_;

    log_print("\nExtracting mRNA entries...");
    if (-s $rnafile) { log_print(" - $rnafile already exists, skipped"); return; }

    my($file, $fileSeqs, $fileLen);
    my $totSeqs = 0; my $totLen = 0;
    my $outfh = gensym; open($outfh, ">$rnafile");
    my(@infiles) = glob($dbfiles);
    foreach $file (@infiles) {
	$fileSeqs = 0;
	$fileLen = 0;
	$_ = `head -1 $file`;
	if (m/^LOCUS/) { # we read a file in genbank format
	    my $src = CONFile->new("$file"); $src->openStream;
	    log_print(" - processing RefSeq-file $file...");
	    my $e;
	    while(defined ($e = $src->getNext)) {
		if (($e->{_CONscn} eq $organism)) {
		    $fileSeqs++;
		    $fileLen += $e->{_CONcdsen} - $e->{_CONcdsst} + 1;
		    print $outfh &genRNAEntry($e->{_CONname}, $e->{_CONdesc},
					      $e->{_CONcdsst},$e->{_CONcdsen},
					      $e->{_seq});
		}
	    }
	    close($src->{_BTFfile});
	} else { # we read a file in EMBL format
	    my $src = EMBLFile->new("$file"); $src->openStream;
	    log_print(" - processing EMBL-file $file...");
	    my $e;
	    while(defined ($e = $src->getNext)) {
		if (($e->{_EMBLscn}[0] ne $organism) ||
		    ($e->{_EMBLtype} ne 'RNA')) { next; } # no RNA entry
		my($begin, $end);
		foreach(@{$e->{_EMBLft}}) { 
		    if (($begin,$end) = m/^CDS\s+(<?\d+)\.\.>?(\d+)$/) { last; }
		}
		if (!defined($begin)) { next; } # no CDS found
		if ((m/>/) && (m/</)) { next; } # frame is undefined

		# all checks passed
		$fileSeqs++;
		$fileLen += $end - $begin + 1;
		print($outfh &genRNAEntry($e->{_EMBLname},$e->{_EMBLdesc},
					  $begin, $end, $e->{_seq}));
	    }
	    close($src->{_BTFfile});
	}
	$totSeqs += $fileSeqs;
	$totLen += $fileLen;
	log_print("   found $fileSeqs sequences, $fileLen coding nucleotides");
    }
    close($outfh);
    log_print(" - overall found $totSeqs sequences, $totLen coding nucleotides");
}

################################################################################
#
#   Analyze GC-content distribution
#

sub analyzeGC {
    # crawl through the RNAs collected mRNA and establish a GC-contents histogram

    my($rnafile) = @_;
    my $datfh = gensym;

    log_print("\nAnalyzing GC contents...");

    my $nb_seqs = 0;
    my @gc_histogram;
    if (-s "$datadir/Report/gc.dat") { 
	log_print(" - loading existing GC-content histogram...");
	open($datfh, "$datadir/Report/gc.dat");
	while(<$datfh>) {
	    my($index, $count) = split;
	    $gc_histogram[$index] = $count;
	    $nb_seqs += $count;
	}
	close($datfh);
	log_print("   read $nb_seqs sequences");
    } else {
	log_print(" - generating GC-content histogram...");
	my $e;
	my $src = FASTAFile->new("$rnafile"); $src->openStream;
	while(defined ($e = $src->getNext)) {
	    my $gc = int(gc_content($e->{_seq}));
	    $gc_histogram[$gc] += 1;
	    $nb_seqs += 1;
	}
	close($src->{_BTFfile});
	log_print("   read $nb_seqs sequences");

	# write datafile
	open($datfh, ">$datadir/Report/gc.dat");
	for (my $i = 0; $i < 100; $i++) { 
	    if (!defined $gc_histogram[$i]) { print $datfh $i, " 0\n"; }
	    else { print $datfh $i, " ", $gc_histogram[$i], "\n"; }
	}
	close($datfh);
    }

    # write the gnu-script for the gc-histogram
    my $scriptfh = gensym;
    open($scriptfh, ">$datadir/Report/gc.gplot");
    print $scriptfh <<EndOfBuffer;
set title "GC-content Histograma "
set xlabel "percentage"
set ylabel "frequency"
set data style boxes
set nokey
plot 'gc.dat'
EndOfBuffer
    close($scriptfh);

    log_print(" - written datafile and gnuplot script");
    return \@gc_histogram;
}

sub gc_content {
    # expectes a nucleotide sequence as entry and computes its
    # gc-content in percentage
    my($seq) = @_;
    my $a = $seq =~ s/A/A/g;
    my $c = $seq =~ s/C/C/g;
    my $g = $seq =~ s/G/G/g;
    my $t = $seq =~ s/T/T/g;
    return 100*($c + $g) / ($a + $c + $g + $t);
}

################################################################################
#
#   Split mRNA data into isochores, test and training sequences
#

sub computeIsochores {
    # according to the GC-contents histogram compute the isochore borders
    # such that close to equal numbers of sequences are contained in the
    # $nb_isochores isochores. If $nb_isochores is zero use the isochore
    # borders defined explicitely.

    my(@isochores, $i);
    my ($nb_isochores, $isochore_borders_ref, $gc_histogram_ref) = @_;
    my @isochore_borders = @{$isochore_borders_ref};
    my @gc_histogram = @{$gc_histogram_ref};
    my $nb_seqs = 0;
    for ($i = 0; $i<= $#gc_histogram; $i++) { $nb_seqs += $gc_histogram[$i]; }

    # compute isochore borders if to be done automatically
    log_print(" - computing isochore borders...");
    if ($nb_isochores == 0) { log_print("   skipped"); }
    else {
	undef @isochore_borders;
	$isochore_borders[0] = 0;
	my $cumulator = 0;
	my $isoIncrement = $nb_seqs/$nb_isochores;
	my $currentTop = $isoIncrement;
	for (my $i = 0; $i < 100; $i++) {
	    $cumulator += $gc_histogram[$i];
	    if ($cumulator > $currentTop) {
		push(@isochore_borders, $i); 
		$currentTop += $isoIncrement;
	    }
	}
	push(@isochore_borders, 100);
    }
    my($buffer) = "   isochores used: ";
    for ($i = 0; $i < $#isochore_borders; $i++) { 
	$isochores[$i] = $isochore_borders[$i] . "-" . $isochore_borders[$i+1];
	$buffer .= $isochores[$i] . ", ";
    }
    chop($buffer);chop($buffer);
    log_print("$buffer");
    return \@isochores;
}

sub splitTraining {
    # Splits the mRNA data into training set and test set. Moreover,
    # generates the isochore partitionning for the training set.

    my($rnafile, $trainingfile, $testfile, $isochores_ref) = @_;
    my @isochores = @{$isochores_ref};
    my $isodir = "$datadir/Isochores";

    log_print("\nSplit mRNA data into isochores, test and training data...");

    log_print(" - writing isochores...");
    my($isochore, @isochorefhs, $isochorefh);

    # check whether isochores and testfile have already been computed
    my($isochoresReady) = 1;
    foreach $isochore (@isochores) {
	if (!(-s "$isodir/mrna$isochore.seq")) { $isochoresReady=0; next; }
	log_print("   $isodir/mrna$isochore.seq already exists");
    }
    if (-s "$trainingfile") { log_print("   $trainingfile already exists"); }
    else { $isochoresReady = 0; }
    if (-s "$testfile") { log_print("   $testfile already exists"); }
    else { $isochoresReady = 0; }

    # write trainingfile, testfile and isochores (CDS)
    if ($isochoresReady == 1) { log_print("   all files exist, skipped"); }
    else{
	# open all isochore files for writing
	foreach $isochore (@isochores) {
	    $isochorefh = gensym; open($isochorefh, ">$isodir/mrna$isochore.seq");
	    push(@isochorefhs, $isochorefh);
	}
	my $trainingfh = gensym; open($trainingfh, ">$trainingfile");
	my $testfh = gensym; open($testfh, ">$testfile");

	# read mRNAs and write the isochores
	my $e;
	my $testSeqs = 0;
	my %isoSeqs;
	my $src = FASTAFile->new("$rnafile"); $src->openStream;
	while(defined ($e = $src->getNext)) {
	    my $gc = gc_content($e->{_seq});
	    for (my $i = 0; $i <= $#isochores; $i++) {
		my($low, $high) = ($isochores[$i] =~ m/^([^\-]+)\-(.*)$/);
		if ($gc < $high) {
		    my($id, $x, $begin, $end, $desc) = split(/ /, $e->{_seqHead}, 5);
		    $isoSeqs{$isochores[$i]}++;
		    if ($isoSeqs{$isochores[$i]}%2){$e->printFASTA($testfh);$testSeqs++;}
		    else { 
			$e->printFASTA($trainingfh);
			my $fh = $isochorefhs[$i];
			print($fh &genRNAEntry($id, $desc, $begin, $end, $e->{_seq})); 
		    }
		    last;
		}
	    }
	}
	close($src->{_BTFfile});

	# close the isochore files
	foreach $isochorefh (@isochorefhs) { close($isochorefh); }
	close($trainingfh);
	close($testfh);
	foreach (sort(keys(%isoSeqs))) {
	    log_print("   ", $isoSeqs{$_}, " sequences found in isochore $_");
	}
	log_print("   $testSeqs of these written into $testfile");
    }
}

sub splitIsochores {
    # Split the mRNAs into isochores (CDS).

    my($rnafile, $isochores_ref) = @_;
    my @isochores = @{$isochores_ref};
    my($isochore, @isochorefhs, $isochorefh);
    my $isodir = "$datadir/Isochores";

    log_print("\nSplit mRNA data into isochores...");

    # check whether isochores have already been computed
    my($isochoresReady) = 1;
    foreach $isochore (@isochores) {
	if (!(-s "$isodir/mrna$isochore.seq")) { $isochoresReady=0; next; }
	log_print("   isochore $isodir/mrna$isochore.seq already exists");
    }

    # write isochores (CDS)
    if ($isochoresReady == 1) { log_print("   all files exist, skipped"); }
    else{
	# open all isochore files for writing
	foreach $isochore (@isochores) {
	    $isochorefh = gensym; open($isochorefh, ">$isodir/mrna$isochore.seq");
	    push(@isochorefhs, $isochorefh);
	}

	# read mRNA and write the isochores
	my $e;
	my %isoSeqs;
	my $src = FASTAFile->new("$rnafile"); $src->openStream;
	while(defined ($e = $src->getNext)) {
	    my $gc = gc_content($e->{_seq});
	    for (my $i = 0; $i <= $#isochores; $i++) {
		my($low, $high) = ($isochores[$i] =~ m/^([^\-]+)\-(.*)$/);
		if ($gc < $high) {
		    $isoSeqs{$isochores[$i]}++;
		    my($id, $x, $begin, $end, $desc) = split(/ /, $e->{_seqHead}, 5);
		    my $fh = $isochorefhs[$i];
		    print($fh &genRNAEntry($id, $desc, $begin,$end, $e->{_seq}));
		    last;
		}
	    }
	}
	close($src->{_BTFfile});

	# close the isochore files
	foreach $isochorefh (@isochorefhs) { close($isochorefh); }
	foreach (sort(keys(%isoSeqs))) {
	    log_print("   ", $isoSeqs{$_}, " sequences found in isochore $_");
	}
    }
}

sub genRNAEntry {
    my($id, $desc, $cdsBegin, $cdsEnd, $seq) = @_;
    $seq =~ s/(.{80})/$1\n/g;
    return ">$id CDS: $cdsBegin $cdsEnd $desc\n$seq\n";
}


sub maskRedundancy {
    # replace redundant regions by 'N' 

    my($minmask, $isochores_ref) = @_;
    my @isochores = @{$isochores_ref};
    log_print("\nMasking redundancy from isochores...");

    my $isochore;
    my $isodir = "$datadir/Isochores";
    foreach $isochore (@isochores) {
	my $maskedFile = "$isodir/mrna$isochore\_mr$minmask.seq";
	if (-s $maskedFile) {  log_print(" - $maskedFile already exists, skipped"); }
	else {
	    my $infile = "$isodir/mrna$isochore.seq";
	    log_print(" - masking redundancy in isochore $isochore");
	    system("maskred -m $minmask < $infile > $maskedFile");
	}
	my $masked = `tail -1 $maskedFile`;
	$masked =~ m/^>masked nucleotides: (\d+)/; my $m = $1;
	my $nts = `grep -v '^>' $maskedFile | wc -c`; chop($nts);
	log_print("   masked $m of $nts nucleotides (" . 100*$m/$nts . "%)");
    }
}

################################################################################
#
#   Generate codon usage tables for HMM-model
#

sub generateEmissionTables {
    # for earch isochore launches maketable, modifying its output in
    # order to mark the isochoers and appends the result to the
    # smatfile.

    my($tuplesize, $pseudocounts, $minscore, $startlength, $startpreroll, $stoplength, 
       $stoppreroll, $isochores_ref, $smatfile, $minmask, $parFile) = @_;
    my @isochores = @{$isochores_ref};
    
    log_print("\nWriting codon usage tables...");

    # makesmat counts in frames, not in codons/triplets, therefore:
    my $startframes = 3 * $startlength;
    my $startoffset = 3 * $startpreroll + 1;
    my $stopframes = 3 * $stoplength;
    my $stopoffset = 3 * $stoppreroll;

    my $isodir = "$datadir/Isochores";
    my $smatfh = gensym; open($smatfh, ">>$smatfile");
    foreach my $iso (sort(@isochores)) {
	log_print(" - computing for isochore $iso...");
	my($low, $high) = $iso =~ m/^([^\-]+)\-(.*)$/;
	$iso .= "_mr$minmask.seq";
	my $cmd = "makesmat -t $tuplesize -p $pseudocounts -m $minscore " . 
	    "-f $startframes -o $startoffset -F $stopframes -O $stopoffset" . 
		" < $isodir/mrna$iso";
	my $out = `$cmd`;
	$out =~ s/<NAME>/$parFile/g;
	$out =~ s/<CG>/$low $high/g;
	print($smatfh $out);
    }
    close($smatfh);
}

################################################################################
#
#   Documentation
#

=head1 NAME

build_model - create a model for ESTScan

=head1 SYNOPSIS

build_model [options] <config-files...>

=head1 DESCRIPTION

build_model generates codon usage tables for ESTScan. Codon usage is
analyzed in mRNAs containing whole coding sequences. mRNA data is
extracted from files in EMBL or RefSeq format. The script reads
configuration files on the comannd line and performs the following
steps for each of them:

 - Extract data from EMBL or RefSeq data files
 - Mask redundant pieces of sequences
 - Split the data into isochores and testsets
 - Compute codon usage tables

Files which already exist are reused. If an existing file is tobe
recomputed, it must be deleted before the script is run again. If a
particular collection of mRNA is to be used instead of data extracted
by build_model, providing these in FASTA format under the name of the
mRNA file (where build_model would store the extracted data) is
enough. In mRNA data, build_model expects annotations of coding
sequence start and stop in the header as two integer values following
the tag 'CDS:'. The first integer points to the first nucleotide of the
CDS, the second to the last. Thus the length of the CDS is <stop> -
<start> + 1. The first nucleotide in the sequence has index 1.

If the '-e' switch is provided, build_model splits the data extracted
from the given databases or provided by the user into training and
test data.

=head1 DIRECTORY STRUCTURE

build_model uses the following directory structure, the root of which
is given in the configuration file. From this root it contains the
following subdirectories:

 - Isochores: data split in isochores, some with redundancy masked
 - Matrices: contains the generated tables
 - Report: contains all log files

mRNA data, test and training data files, is dposited in the data-root
directory if not otherwise specified in the configuration file.

=head1 OPTIONS

 -q quiet
    Do not log on terminal.

 -e split data into test and training
    If this switch is provided extracted mRNA data is split into
    training and test set. As sequences are extracted they are
    alternately deposited in the training and the test set..

 -t <tuple-size> 
    Size of tuples to be considered to generate the codon usage
    tables. <tuple-size> - 1 is the order of the corresponding Markov
    model used by ESTScan. This switch overwrites the variable
    $tuplesize from paramter files.

 -m <minmask>
    Minimum consecutive runs of nucleotides masked from the original
    sequences in order to limit data redundancy. Pieces of sequence
    are only masked, if all of their nucleotides are part of
    reoccuring 12-tuples which overlap by at least 4 nucleotides. This
    switch overwrites the variable $minmask from paramter files.

 -p pseudocount
    Pseudocounts to be added when generating codon usage tables.  This
    switch overwrites the variable $pseudocounts from paramter files.

 -s <minscore>
    Minimal score in tables and transitions, lower scores are
    overwritten with this value. This switch overwrites the variable
    $minscore from paramter files.

 -l <start-profile-length>
    The number of nucleotide triplets taken into account for the
    start-profile. This switch overwrites the variable $startlength
    from paramter files.

 -r <start-profile-preroll>
    The number of nucleotide triplets of the 5' untranslated region
    contained in the start profile. This switch overwrites the
    variable $startpreroll from paramter files.

 -L <stop-profile-length>
    The number of nucleotide triplets taken into account for the
    stop-profile. This switch overwrites the variable $stoplength from
    paramter files.

 -R <stop-profile-preroll>
    The number of nucleotide triplets of the coding sequence contained in the
    stop profile. This switch overwrites the variable $stoppreroll
    from paramter files.

=head1 CONFIGURATION FILE

The parameters defined in the configuration file have the
following meaning:

 * $organism (mandatory) 
    The desired organism as it is given in EMBL "OS" or RefSeq
   "ORGANISM" lines.

 * $dbfiles 
   Files from where full-length mRNA sequences are to be extracted,
   tries to guess whether the files come from EMBL or RefSeq. If 
   this is not specified, expects a collection of mRNA in $rnafile.

 * $datadir (mandatory)
   Base directory where all of the above files are located
   and the temporary result files are stored

 * $rnafile (default is "$datadir/mrna.seq")
   Name of the file with the extracted mRNA entries.

 * $smatfile (default is "$datadir/Matrices/$filestem.smat")
   Name of the file where the HMM-model is to be written

 * $nb_isochores (default is 0)
   Number of isochores, when isochores are to be determined
   automatically from the GC-content distributaion as equal-sized
   groups. 0 means,no automatic detection.

 * @isochore_borders (default is (0, 43, 47, 51, 100)
   Array of GC percentages where isochores are split, first entry is
   usually 0 and last 100. This is overwritten when $nb_isochores is
   not zero.

 * $tuplesize (default is 6)
   Size of tuples counted for codon statistics. This is overwritten by
   the -t switch. 

 * $minmask (default is 30)
   Minimal run of consecutive nucleotides masked as redundant. This is
   overwritten by the -m swith. 

 * $pseudocounts (default is 1)
   pseudocount to be added when generating the codon usage tables,
   overwritten by -m

 * $minscore (default is -100)
   minimum score attributed to log-odds and log-probabilities,
   overwritten by -s.

 * $startlength, $startpreroll (default 2+ceil(tuplesize/3) and 2)
   number of nucleotide triplets contained in the start profile and
   how many of these are contained in the 5' untranslated region,
   overwritten by -l (length) and -r (preroll)

 * $stoplength, $stoppreroll (default 2+ceil(tuplesize/3) and 2)
   number of nucleotide triplets contained in the stop profile and
   how many of these are contained in the coding sequence,
   overwritten by -L (length) and -R (preroll)

 * $estscanparams (default is "-m -50 -d -50 -i -50 -N 0")
   parameters passed to ESTScan during evaluation

$filestem is used to generate many filenames. It is generated
automatically according to the tuplesize, the minmask and the
pseudocounts applied to generate them.

=head1 AUTHOR

Claudio Lottaz, SIB-ISREC, Claudio.Lottaz@isb-sib.ch

=cut

#
#   End of file
#
################################################################################
