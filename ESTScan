#!/usr/local/bin/perl 

# $Id: ESTScan,v 1.26 2001/06/11 11:58:10 clottaz Exp $
#
# Christian Iseli, LICR ITO, Christian.Iseli@licr.org
#
# Copyright (c) 1999, 2000 Swiss Institute of Bioinformatics. All rights reserved.

use strict;
use Getopt::Long;
use FASTAFile;
use ESTScan;

$| = 1; # Very important, otherwise get garbled output in batch mode.

my $ESTScanDir = $ENV{"ESTSCANDIR"};
if ($ESTScanDir eq "") {
    $ESTScanDir = "/usr/molbio/share/ESTScan";
}

$main::copyright = <<EndOfMsg;
This is ESTScan version 1.1a (June 2001)
Copyright (c) 1999, 2000 by the Swiss Institute of Bioinformatics.
All rights reserved. See the file COPYRIGHT for details.
EndOfMsg

my %opt;
my @options = ( "help", "m=i", "d=i", "i=i", "c=i", "D=i", "M=s",
		"p=f", "N=i", "w=i", "a!", "O!", "F=s", "f=f", "s=i",
		"t=s", "o=s", "b=f", "g!", "start!", "stop=i", "nc!", 
	       "n!", "v!" );

# Properly initialize Getopt for our purposes...
Getopt::Long::Configure("no_ignore_case");

$main::version = 1.1;

if( ! GetOptions( \%opt, @options ) ) { &usage(); }

$main::absolut = 0; # ;-)
$main::min     = -50;
$main::dPen    = -50;
$main::iPen    = -50;
$main::cutoff  = undef;
$main::dropMax = 200;
$main::matrix  = "$ESTScanDir/HumanIso.smat";
$main::percent = 4.0;
$main::Nvalue = 0;
$main::sWidth = 60;
$main::all = 0;
$main::maxOnly = 0;
$main::FPRMat = "$ESTScanDir/Human5550.fpr";
$main::FPR = 0.1;
$main::skipLen = 1;
$main::transl = undef;
$main::out = \*STDOUT;
$main::both = 1.0;
$main::no_del = 0;
$main::start = 0;
$main::stop = 0;
$main::noncoding = 0;
$main::graph = 0;

&usage() if defined $opt{'help'};

$main::min       = $opt{'m'}     if defined $opt{'m'};
$main::dPen      = $opt{'d'}     if defined $opt{'d'};
$main::iPen      = $opt{'i'}     if defined $opt{'i'};
$main::dropMax   = $opt{'D'}     if defined $opt{'D'};
$main::matrix    = $opt{'M'}     if defined $opt{'M'};
$main::percent   = $opt{'p'}     if defined $opt{'p'};
$main::Nvalue    = $opt{'N'}     if defined $opt{'N'};
$main::sWidth    = $opt{'w'}     if defined $opt{'w'};
$main::all       = $opt{'a'}     if defined $opt{'a'};
$main::maxOnly   = $opt{'O'}     if defined $opt{'O'};
$main::skipLen   = $opt{'s'}     if defined $opt{'s'};
$main::both      = $opt{'b'}     if defined $opt{'b'};
$main::no_del    = $opt{'n'}     if defined $opt{'n'};
$main::start     = $opt{'start'} if defined $opt{'start'};
$main::stop      = $opt{'stop'}  if defined $opt{'stop'};
$main::noncoding = $opt{'nc'}    if defined $opt{'noncoding'};
$main::graph     = $opt{'g'}     if defined $opt{'g'};
if (defined $opt{'t'}) {
    if ($opt{'t'} eq "-") {
	$main::transl = \*STDOUT;
    } else {
	use Symbol;
	my $path = $opt{'t'};
	$main::transl = gensym;
	if (!(open $main::transl, ">$path")) {
	    warn "Could not create file \"$path\": $!";
	    exit 1;
	}
    }
}
if (defined $opt{'o'}) {
    if ($opt{'o'} eq "-") {
	$main::out = \*STDOUT;
    } else {
	use Symbol;
	my $path = $opt{'o'};
	$main::out = gensym;
	if (!(open $main::out, ">$path")) {
	    warn "Could not create file \"$path\": $!";
	    exit 1;
	}
    }
}
if (defined $opt{'c'}) {
    $main::cutoff = $opt{'c'};
    $main::absolut = 1;
}
if (defined $opt{'F'}) {
    die "No need for -F when using absolute cutoff" if $main::absolut == 1;
    $main::FPRMat = $opt{'F'};
}
if (defined $opt{'f'}) {
    die "No need for -f when using absolute cutoff" if $main::absolut == 1;
    $main::FPR = $opt{'f'};
}
if (defined $opt{'v'}) {
    print $main::copyright;
    exit 0;
}

&usage() if $#ARGV < 0;

# Load all the matrices.
my @mat = ESTScan::LoadMatrix($main::matrix, "CODING", $main::percent);
if ($main::start)     { push @mat, ESTScan::LoadMatrix($main::matrix, "START",     $main::percent); }
if ($main::stop)      { push @mat, ESTScan::LoadMatrix($main::matrix, "STOP",      $main::percent); }
if ($main::noncoding) { push @mat, ESTScan::LoadMatrix($main::matrix, "NONCODING", $main::percent); }
for my $i (0 .. $#mat) {
    my $order = $ {$mat[$i]}[3];
    my $length = $ {$mat[$i]}[4];
    my $offset = $ {$mat[$i]}[5];
    my $aRef = $ {$mat[$i]}[8];
    my $ref = ESTScan::CreateMatrix($order, $length, $offset, $aRef, $main::min, $main::Nvalue);
}
# Load the false positive rate matrices, unless using absolut.
if ($main::absolut == 0) { 
    ESTScan::LoadFPRMatrices($main::FPRMat, $main::start); 
}

my $src = FASTAFile->new($ARGV[0]);
$src->openStream;
my $seq;
my $seqCtr = 0;
while (defined($seq = $src->getNext)) {
#    print STDERR "$seqCtr sequences done\n";
    $seqCtr++;
    my $length = $seq->seqLength;
    next if $length < $main::skipLen;
    # Do not use total length, i.e., use only good nt.
    my $countGC = $seq->{_seq} =~ s/([CG])/$1/g;
    my $countAT = $seq->{_seq} =~ s/([AT])/$1/g;
    next if ($countGC + $countAT) == 0;
    my $percent = $countGC / ($countGC + $countAT) * 100.0;
#    print "percent is $percent\n";
    # Find the correct matrices.
    my $matIndex = FindMatrix('CODING', $percent, \@mat);
    if ($matIndex == -1) { warn "No coding matrix found for $percent % GC."; next; }
    my $startMatIndex = -1;
    if ($main::start) {
	$startMatIndex = FindMatrix('START', $percent, \@mat);
	if ($startMatIndex == -1) { warn "No start matrix found for $percent % GC."; }
    }
    my $stopMatIndex = -1;
    if ($main::stop) {
	$stopMatIndex = FindMatrix('STOP', $percent, \@mat);
	if ($stopMatIndex == -1) { warn "No stop matrix found for $percent % GC."; }
    }
    my $ncMatIndex = -1;
    if ($main::noncoding) {
	$ncMatIndex = FindMatrix('NONCODING', $percent, \@mat);
	if ($ncMatIndex == -1) { warn "No non-coding matrix found for $percent % GC."; }
    }

    if ($main::absolut == 0) {
	# Find correct cutOff value
	$main::cutoff = ESTScan::ComputeCutOff($percent, $length, $main::FPR);
    }
    my $id = "";
    my $idrev = "";
    my $graphName = "";
    if ($main::graph == 1) { 
	$id = $seq->seqHead;
	$id =~ s/^> ?(\S+).*/$1/;
	$id =~ s/\|//g;
	use Symbol;
	my $FH = gensym;
        my $gnuplotCommands = 
	    "set terminal postscript enhanced\n".
	    "set title 'Scores of $id'\n".
            "set data style lines\n".
            "set xlabel 'Position in Sequence'\n".
	    "set ylabel 'Score'\n".
            "plot '$id.dat'\n";
	if (!(open $FH, ">$id.gplot")) { 
	    warn "Could not create file \"$id.gplot\": $!"; exit 1; 
	}
	print $FH $gnuplotCommands;
	close $FH;
	$idrev = $id."rev";
	$gnuplotCommands =~ s/$id/$idrev/g;
	if (!(open $FH, ">$idrev.gplot")) { 
	    warn "Could not create file \"".$id."rev.gplot\": $!"; exit 1; 
	}
	print $FH $gnuplotCommands;
	close $FH;
	$graphName = "./$id.dat";
    }
    my @res;
    my $bigMax = ESTScan::Compute($seq->{_seq}, $main::iPen, $main::dPen,
				  $main::cutoff, $main::dropMax,
				  $main::maxOnly == 0 ? \@res : undef, $matIndex,
				  $startMatIndex, $stopMatIndex, $main::stop, 
				  $ncMatIndex, $graphName);
    my @resRev;
    if ($main::graph == 1) { $graphName = "$idrev.dat"; }
    my $seqRev = $seq->revComp;
    my $bigMaxRev = ESTScan::Compute($seqRev->{_seq}, $main::iPen, $main::dPen,
				     $main::cutoff, $main::dropMax,
				     $main::maxOnly == 0 ? \@resRev : undef, $matIndex,
				     $startMatIndex, $stopMatIndex, $main::stop, 
				     $ncMatIndex, $graphName);

    if ($main::graph == 1) { 
	system("cat $id.dat.coding $id.dat.start > $id.dat");
	system("gnuplot $id.gplot > $id.ps");
	system("rm $id.dat.coding $id.dat.start");
	system("cat '$idrev.dat.coding' '$idrev.dat.start' > '$idrev.dat'");
	system("gnuplot $idrev.gplot > $idrev.ps");
	system("rm $idrev.dat.coding $idrev.dat.start");
    }
    
    my $result_nr = -1;
    my $theRealMax = $bigMax >= $bigMaxRev ? $bigMax : $bigMaxRev;
    if ( $main::absolut == 0) { $theRealMax = normalizedScore($theRealMax); }
    showResults($seq, \@res, $bigMax, \$result_nr, $theRealMax);
    showResults($seqRev, \@resRev, $bigMaxRev, \$result_nr, $theRealMax);
}
exit 0;

sub usage {
    print "$main::copyright
  Usage: ESTScan [options] <file>
  where options are:
   -m <int>     min value in matrix [$main::min]
   -d <int>     deletion penalty [$main::dPen]
   -i <int>     insertion penalty [$main::iPen]
   -D <int>     maximum drop value [$main::dropMax]
   -M <file>    score matrices file (\$ESTSCANDIR/HumanIso.smat)
                [$main::matrix]
   -p <float>   GC select correction for score matrices [$main::percent]
   -N <int>     how to compute the score of N [$main::Nvalue]
   -w <int>     width of the FASTA sequence output [$main::sWidth]
   -a           All in one sequence output [$main::all]
   -O           report header information for best match only [$main::maxOnly]
   -b <float>   only results is shown, which have scores higher than this 
                fraction of the best score [$main::both].
   -n           remove deleted nucleotides from the output ($main::no_del)
   -t <file>    Translate to protein.  - means stdout.
                will go to the file and the nucleotides will still go to stdout.
   -o <file>    send output to file.  - means stdout.  If both -t and -o specify
                stdout, only proteins will be written.
   -f <float>   expected false positive rate [$main::FPR]
   -F <file>    false positive rate matrices file (\$ESTSCANDIR/Human5550.fpr)
                [$main::FPRMat]
   -s <int>     Skip sequences shorter than length [$main::skipLen]
   -c <int>     cutoff value (no normalization) [undefined]
   -start       use start model [$main::start]
   -stop <int>  distince within to search for stop profiles [$main::stop]
   -v           version information

ESTScan returns results (coding sequences( in FASTA format adding the following 
information to the header: normalized score, absolute score, cutoff, start and 
stop position. These values are added in the cited order after the name of the
coding sequence.\n";
    exit 1;
}

sub FindMatrix {
    my ($type, $percent, $mat) = @_;
    my $i;
    for ($i = 0; $i <= $#$mat; $i++) {
	if ($percent >= $ {$$mat[$i]}[6] && $percent <= $ {$$mat[$i]}[7] &&
	    $type eq $ {$$mat[$i]}[1]) {
#???	    return( $ {$$mat[$i]}[9] );
	    return( $i );
	}
    }
    return -1;
}

sub normalizedScore {
    my ($score) = @_;
    if ($main::absolut == 1) {
	return $score;
    }
    my $frac = $score / $main::cutoff;
    if ($frac == 0.0) {
	$frac = 0.000001;
    }
    $score = log ($frac);
    return sprintf "%.1f", $score * 100.0;
}

sub showResults {
    my ($seq, $rres, $bigMax, $cnt, $theRealMax) = @_;
    if ($main::maxOnly != 0) {
	my $score;
	my $head = $seq->seqHead;
	if ($main::absolut == 0) {
	    $score = normalizedScore($bigMax);
	    $head =~ s/^(\S+)/$1 $score $bigMax $main::cutoff/;
	} else {
	    $score = $bigMax;
	    $head =~ s/^(\S+)/$1 $bigMax/;
	}
	if (($theRealMax * $main::both <= $score) && ($$cnt == -1)) { 
	    print $main::out "$head\n";
	    $$cnt += 1;
	}
	return;
    }
    if ($main::all == 1 && $#$rres >= 0) {
	my $scores = "";
	my $outSeq = "";
	my $lastPos = 0;
	foreach my $r (@$rres) {
	    my $curScore = normalizedScore($$r[0]);
	    $scores .= $curScore . " ";
	    if ($theRealMax * $main::both > $curScore) { next; }
	    if ($$r[1] > $lastPos) {
		my $s = substr($seq->{_seq}, $lastPos, $$r[1] - $lastPos);
		$s =~ tr/A-Z/a-z/;
		$outSeq .= $s;
	    }
	    $outSeq .= $$r[3];
	    $lastPos = $$r[2] + 1;
	}
	if ($lastPos < $seq->seqLength) {
	    my $s = substr($seq->{_seq}, $lastPos);
	    $s =~ tr/A-Z/a-z/;
	    $outSeq .= $s;
	}
	my $head = $seq->seqHead;
	$head =~ s/^(\S+)/$1 $scores/;
	print $main::out "$head\n";
	$outSeq =~ s/(.{$main::sWidth})/$1\n/g;
	$outSeq =~ s/\s+$//; # remove a trailing newline, since we add one below.
	print $main::out "$outSeq\n";
	return;
    }
    foreach my $r (@$rres) {
	my $score = $main::absolut == 0 ? normalizedScore($$r[0]) : $$r[0];
	if ($theRealMax * $main::both > $score) { next; }
 
	# Should remove lower cases if we want to create a correct sequence.
	my $rSeq = $$r[3];
	my $head = $seq->seqHead;
	if ($$cnt >= 0) {
	    my $c = chr(ord("a") + $$cnt);
	    $head =~ s/^([^|]+)\|([^| ]+)/$1|$2$c/;
	}
	$$cnt += 1;
	my $start = $$r[1] + 1;
	my $end = $$r[2] + 1;
	if ($main::absolut == 0) {
	    $head =~ s/^(\S+)/$1 $score $$r[0] $main::cutoff $start $end /;
	} else {
	    $head =~ s/^(\S+)/$1 $$r[0] $start $end /;
	}
	if (defined $main::transl) {
	    my $pSeq = $rSeq;
	    $pSeq =~ s/[acgt]//g; # Remove lowercases...
	    $pSeq = BTLib::na2aa($pSeq);
	    print $main::transl "$head; translated\n";
	    $pSeq =~ s/(.{$main::sWidth})/$1\n/g;
	    $pSeq =~ s/O$//; # remove trailing stop codon
	    $pSeq =~ tr/O/X/; # translate intermediate stop codons by X
	    print $main::transl "$pSeq\n";
	    next if $main::transl == \*STDOUT && $main::out == \*STDOUT;
	}
	print $main::out "$head\n";
	if ($main::no_del) { $rSeq =~ s/[acgt]//g; }
	$rSeq =~ s/(.{$main::sWidth})/$1\n/g;
	$rSeq =~ s/\s+$//; # remove a trailing newline, since we add one below.
	print $main::out "$rSeq\n";
    }
}
